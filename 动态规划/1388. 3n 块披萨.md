# [1388. 3n 块披萨](https://leetcode.cn/problems/pizza-with-3n-slices/)

给你一个披萨，它由 3n 块不同大小的部分组成，现在你和你的朋友们需要按照如下规则来分披萨：

- 你挑选 **任意** 一块披萨。
- Alice 将会挑选你所选择的披萨逆时针方向的下一块披萨。
- Bob 将会挑选你所选择的披萨顺时针方向的下一块披萨。
- 重复上述过程直到没有披萨剩下。

每一块披萨的大小按顺时针方向由循环数组 `slices` 表示。

请你返回你可以获得的披萨大小总和的最大值。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/21/sample_3_1723.png)

```
输入：slices = [1,2,3,4,5,6]
输出：10
解释：选择大小为 4 的披萨，Alice 和 Bob 分别挑选大小为 3 和 5 的披萨。然后你选择大小为 6 的披萨，Alice 和 Bob 分别挑选大小为 2 和 1 的披萨。你获得的披萨总大小为 4 + 6 = 10 。
```

**示例 2：**

**![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/21/sample_4_1723.png)**

```
输入：slices = [8,9,8,6,1,1]
输出：16
解释：两轮都选大小为 8 的披萨。如果你选择大小为 9 的披萨，你的朋友们就会选择大小为 8 的披萨，这种情况下你的总和不是最大的。
```

## 方法 动态规划

前言
本题可以转化成如下问题：

- 给一个长度为3n的环状序列，你可以在其中选择n个数，并且任意两个数不能相邻，求这n个数的最大值。

为什么可以这样转化呢？我们只需要证明，对于任意一种在长度为3n的环状序列上选择n个不相邻数的方法，都等价于一种题目中挑选披萨的方法。我们使用数学归纳法，证明如下：

- 当n=1时，我们在3个数中任选1个，由于这是一个环状序列，因此选取其中的任意一个数，剩余的两个数都会在选取的数的两侧，即如果有3块披萨，我们可以选取其中的任意一块；

- 当n≥2时，一定存在一个数x，使得x的某一侧有连续两个数没有被选择（假设所有选中不相邻数的间隔为1，即中间只有一个数没有被选择，那么总数为2n，与总数为3n矛盾）。不失一般性，我们设x的左侧有连续两个数没有被选择，并且x的右侧至少有一个数没有没选择（否则x和其右侧的数就相邻了），即：⋯ ,?,0,0,x,0,?,···。其中0表示这个数没有被选择，?表示这个数选择的情况未知（即我们不需要考虑，它可能被选择，也可能没有被选择）。我们删去x以及左右两侧的数，得到：⋯ ,?,0,?,⋯ 

- 将长度为3n的环状序列变成了长度为3(n−1)的环状序列，并且该环状序列中有n−1个数被选取，且任意两个被选取的数不相邻。对应到披萨上，相当于我们挑选了数x对应未知的披萨，而 Alice 和 Bob 挑选了相邻的两块披萨。这样我们将问题的规模从n减小至n-1，通过数学归纳法得证。

同时，经过观察可发现，原方法选出的披萨一定都不相邻。结合上面的证明，命题的充分必要性得证。

因此，我们需要设计算法，在长度为3n的环状序列中选择n个不相邻的数，使得这n个数的和最大。

我们首先考虑该序列不是环状时的解决方法，即给定的是长度为3n的普通序列。我们可以用$dp[i][j]$表示在前i个数中选择了j个不相邻的数的最大和：

当$i<2或j=0$时，有：
$$
dp[i][j]=
\begin{cases}
0, \quad j = 0\\
slices[0], \quad i=0,j=1\\
max(slices[0],slices[1]),\quad i=1,j=1\\
-\infty, \quad i<2,j>2

\end{cases}
$$
当$i\geq2且j>0$时，$dp[i][j]$的状态转移方程为：
$$
dp[i][j] = max(dp[i-2][j-1]+slices[i],dp[i-1][j])
$$
当该序列是环状序列时，我们应该如何求解呢？我们可以发现，环状序列相较于普通序列，相当于添加了一个限制：普通序列中的第一个和最后一个数不能同时选。这样一来，我们只需要对普通序列进行两遍动态即可得到答案，第一遍动态规划中我们删去普通序列中的第一个数，表示我们不会选第一个数；第二遍动态规划中我们删去普通序列中的最后一个数，表示我们不会选最后一个数。将这两遍动态规划得到的结果去较大值，即为在环状序列上的答案。

## 代码

```c++
class Solution {
public:
    int maxSizeSlices(vector<int>& slices) {
        vector<int>v1(slices.begin(),slices.end()-1);
        vector<int>v2(slices.begin()+1,slices.end());
        int ans1 = calculate(v1);
        int ans2 = calculate(v2);
        return max(ans1,ans2);

    }

    int calculate(const vector<int>&slices) {
        int N = slices.size();
        int n = (N+1)/3;
        vector<vector<int>>dp(N,vector<int>(n+1,INT_MIN));
        dp[0][0] = 0;
        dp[0][1] = slices[0];
        dp[1][0] = 0;
        dp[1][1] = max(slices[0],slices[1]);
        for(int i = 2;i<N;i++) {
            dp[i][0] = 0;
            for(int j = 1;j<=n;j++) {
                dp[i][j] = max(dp[i-2][j-1]+slices[i],dp[i-1][j]);

            }
        }
        return dp[N-1][n];
    }
};
```

