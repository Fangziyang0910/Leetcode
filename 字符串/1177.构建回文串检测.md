# [1177. 构建回文串检测](https://leetcode.cn/problems/can-make-palindrome-from-substring/)

## 题目

给你一个字符串 `s`，请你对 `s` 的子串进行检测。

每次检测，待检子串都可以表示为 `queries[i] = [left, right, k]`。我们可以 **重新排列** 子串 `s[left], ..., s[right]`，并从中选择 **最多** `k` 项替换成任何小写英文字母。 

如果在上述检测过程中，子串可以变成回文形式的字符串，那么检测结果为 `true`，否则结果为 `false`。

返回答案数组 `answer[]`，其中 `answer[i]` 是第 `i` 个待检子串 `queries[i]` 的检测结果。

注意：在替换时，子串中的每个字母都必须作为 **独立的** 项进行计数，也就是说，如果 `s[left..right] = "aaa"` 且 `k = 2`，我们只能替换其中的两个字母。（另外，任何检测都不会修改原始字符串 `s`，可以认为每次检测都是独立的）

 

**示例：**

```
输入：s = "abcda", queries = [[3,3,0],[1,2,0],[0,3,1],[0,3,2],[0,4,1]]
输出：[true,false,false,true,true]
解释：
queries[0] : 子串 = "d"，回文。
queries[1] : 子串 = "bc"，不是回文。
queries[2] : 子串 = "abcd"，只替换 1 个字符是变不成回文串的。
queries[3] : 子串 = "abcd"，可以变成回文的 "abba"。 也可以变成 "baab"，先重新排序变成 "bacd"，然后把 "cd" 替换为 "ab"。
queries[4] : 子串 = "abcda"，可以变成回文的 "abcba"。
```

## 方法：前缀异或

## 一、思考

回文意味着什么？

题目允许重新排列字母，那么以字母 aa 为例，它要如何排列？偶数个 aa 要如何排列？奇数个 aa 要如何排列？

什么情况下**一定**要替换字母？要替换多少个？

如何快速求出子串中每种字母的个数？

## 二、解惑

回文意味着从左往右第*i*个字母和从右往左第i个字母是相同的。（回文串关于回文中心是对称的。）

如果有偶数个a，那么可以均分成两部分，分别放置在字符串的中心对称位置上。例如有4个a，可以在字符串的最左边放置2个a，最右边放置2个a，这样字符串中的a是回文的。其它字母如果出现偶数次，也同理。

如果有奇数个a，多出的一个a要单独拿出来讨论：

- 假如只有a出现奇数次，其它字母都出现偶数次。此时字符串的长度一定是奇数，那么可以把多出的这个a放在字符串的中心，我们仍然可以得到一个回文串，无需替换任何字母。
- 如果有两种字母出现奇数次（假设是字母a,b），由于多出的一个a 和一个b无法组成回文串，可以把一个b改成a（或者把一个a改成 b），这样a和b就都出现偶数次了。
- 如果有三种字母出现奇数次（假设是字母a,b,c），把一个b改成c，就转换成只有a出现奇数次的情况了。
- 一般地，如果有*m*种字母出现奇数次，只需修改其中 ⌊m/2⌋个字母。换句话说，如果第i次询问有⌊m/2⌋≤*k*，那么answer[i] 为真，反之为假。

最后要解决的问题是，如何快速求出子串中每种字母的个数？

可以创建26个**前缀和**数组，分别统计每种字母。以字母a为例，在计算前缀和时，如果s[i]=a 就视作1，否则视作0。

## 三、算法（优化前）

```
class Solution:
    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:
        sum = [[0] * 26]
        for c in s:
            sum.append(sum[-1].copy())
            sum[-1][ord(c) - ord('a')] += 1

        ans = []
        for left, right, k in queries:
            m = 0
            for sl, sr in zip(sum[left], sum[right + 1]):
                m += (sr - sl) % 2  # 奇数+1，偶数+0
            ans.append(m // 2 <= k)
        return ans
```

#### 复杂度分析

- 时间复杂度O((*n*+*q*)⋅∣Σ∣)，其中n为s的长度,q为 queries的长度,∣Σ∣为字符集合的大小。本题中字符均为小写字母，所以∣Σ∣=26。
- 空间复杂度：O(*n*⋅∣Σ∣)。返回值不计入。

## 四、一步步优化

由于只关心每种字母出现次数的奇偶性，所以不需要在前缀和中存储每种字母的出现次数，只需要保存每种字母出现次数的奇偶性。

为方便计算，用0表示出现偶数次，用1表示出现奇数次。

注意只有奇数减偶数，或者偶数减奇数，才能得到奇数。所以如果相减的结果不为0（或者说相减的两个数不相等），就表示出现了奇数次。

由于异或运算满足1和0的结果是1，而0 和0，以及1和1的结果都是0，所以可以用异或替换上面的减法。

由于长为26的数组中只存储0和1，可以压缩到一个二进制数中，二进制数从低到高第i个比特存储着0和1的信息。

例如二进制10010表示b和e出现奇数次，其余字母出现偶数次。

在计算前缀和时（准确地说是异或前缀和）：

- 修改a出现次数的奇偶性，可以异或二进制1；
- 修改b出现次数的奇偶性，可以异或二进制10；
- 修改c出现次数的奇偶性，可以异或二进制100；
- 依此类推。

此外，由于异或可以「并行计算」，对前缀和中的两个二进制数直接异或，便得到了子串中每种字母出现次数的奇偶性。再计算这个二进制数中的1的个数，便得到了m。

```
class Solution {
public:
    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {
        int n = s.length(),q = queries.size(),sum[n+1];
        sum[0] = 0;
        for(int i = 0;i<n;i++)
        {
            int bit = 1 << (s[i]-'a'); //构建当前的数量
            sum[i+1] = sum[i] ^ bit;  //用异或运算代替统计
        }
        vector<bool>ans(q);
        for(int i = 0;i<q;i++)
        {
            int left = queries[i][0],right = queries[i][1],k = queries[i][2];
            int m = __builtin_popcount(sum[right + 1] ^ sum[left]);  //统计32位整数中的1的数目
            ans[i] = m/2 <=k;
        }
        return ans;
    }
};
```

#### 复杂度分析

- 时间复杂度：O(*n*+*q*)，其中*n* 为 nums* 的长度，q为queries* 的长度。
- 空间复杂度：O(*n*)。