# 1073.[负二进制数相加](https://leetcode.cn/problems/adding-two-negabinary-numbers/)

## 题目
给出基数为 -2 的两个数 arr1 和 arr2，返回两数相加的结果。

数字以 数组形式 给出：数组由若干 0 和 1 组成，按最高有效位到最低有效位的顺序排列。例如，**arr = [1,1,0,1] 表示数字 (-2)^3 + (-2)^2 + (-2)^0 = -3**。数组形式 中的数字 arr 也同样不含前导零：即 arr == [0] 或 arr[0] == 1。

返回相同表示形式的 arr1 和 arr2 相加的结果。两数的表示形式为：**不含前导零、由若干 0 和 1 组成的数组。**

---

## 方法1：进制转换
无论是几进制的数字序列，都可以将其转为十进制之后进行运算。最后将运算结果再转换为对应进制的数字序列。但是这样做引入和非必要的转换，并不是最优解。
##方法2：加法器模拟

###思路与分析

#### 传统二进制加法：
设置一个进位端carry，加法是从低位开始运算的，计算结果中对应位数的结果x为两个被加数的对应数位数字和进位的和。在二进制中，x只会是{0，1，2，3}中的一个。其中x为0和1不需要进位，x为2，3则需要进位，设置carry为1，当前数位值为x-2;
#### 负二进制加法：
同样设置进位端，我们假设i两个数字序列中的第i个数字。暂时不考虑进位，那么对应数位产生的结果为{0，1，2}，当结果x为2的时候要进位。由于$2^i+2^i = 2^{i+1}$但是负二进制中，下一个数位j为$2^j = -2^{i+1}$,所以此时**产生的进位不是1而是-1**。所以考虑进位-1后x的取值为{-1，0，1，2}。

请注意当x为-1的时候会产生类似于减法器中的**借位问题**。我们需要从高位借位，将此时的x值变更为2-1=1。产生借位的时候，$2*2^i = -2^j$所以借位后高位的进位值并非-1而是+1。设置carry值为1进入下一位的计算。

总结：设置高位进位端，该值同时承担了进位和类似于减法的借位功能。

#### 需要注意的点：
* **计算终止条件：**当两个数字序列都遍历结束并且进位值为0的时候进位才*结束。

* 加法模拟从低位开始模拟，**保存的结果是反序的**，需要在最后reverse一下。
* **结果中不含有前序0**，可以在reverse前检查并pop_back,注意如果结果为0需要保存结果0。

~~~C++
class Solution {
public:
    vector<int> addNegabinary(vector<int>& arr1, vector<int>& arr2) {
        int i = arr1.size() - 1, j = arr2.size() - 1;
        int carry = 0;
        vector<int> ans;
        while (i >= 0 || j >= 0 || carry) {
            int x = carry;
            if (i >= 0) {
                x += arr1[i];
            }
            if (j >= 0) {
                x += arr2[j];
            }
            
            if (x >= 2) {
                ans.push_back(x - 2);
                carry = -1;
            }
            else if (x >= 0) {
                ans.push_back(x);
                carry = 0;
            }
            else {
                ans.push_back(1);
                carry = 1;
            }
            --i;
            --j;
        }
        while (ans.size() > 1 && ans.back() == 0) {
            ans.pop_back();
        }
        reverse(ans.begin(), ans.end());
        return ans;
    }
};
~~~

###复杂度分析

####时间复杂度
*O*(max(m,n)),m,n分别为arr1和arr2的长度
####空间复杂度
O(1)