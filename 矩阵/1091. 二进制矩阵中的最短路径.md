# [1091. 二进制矩阵中的最短路径](https://leetcode.cn/problems/shortest-path-in-binary-matrix/)

## 题目
给你一个 $n * n$ 的二进制矩阵 $grid$ 中，返回矩阵中最短**畅通路径**的长度。如果不存在这样的路径，返回 -1 。

二进制矩阵中的**畅通路径**是一条从左上角单元格（即，$(0, 0)$）到右下角单元格（即，$(n - 1, n - 1)$）的路径，该路径同时满足下述要求：

- 路径途经的所有单元格的值都是 0 。
- 路径中所有相邻的单元格应当在 8 个方向之一 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。
- 畅通路径的长度 是该路径途经的单元格总数。

**示例 1：**

![1](../pic/1091.1.png)

    输入：grid = [[0,1],[1,0]]
    输出：2

**示例 2：**

![2](../pic/1091.2.png)

    输入：grid = [[0,0,0],[1,1,0],[1,1,0]]
    输出：4

## 方法一：广度优先搜索

把单元格当成图的节点，如果两个相邻单元格的值都是0,那么这两个相邻单元格代表的节点之间存在边，且边长为 1。因此问题可以转化为给定一个无权图，求两个节点的最短路径。求无权图的最短路径问题的解法是**广度优先搜索。**

首先如果 grid[0][0]=1,那么显然不存在最短路径，因此返回−1。使用 dist[x][y] 保存左上角单元格(0,0) 到某一单元格(x,y) 的最短路径，初始时dist[0][0]=1。首先，我们将单元格 (0,0) 放入队列中，然后不断执行以下操作：
如果队列为空，那么返回 −1。从队列中取出单元格 (x,y)，如果该单元格等于右上角单元格，那么返回 dist[x][y]。

遍历该单元格的所有相邻单元格，如果相邻单元格 (x1,y1) 的值为0且未被访问，那么令 dist[x1][y1]=dist[x][y]+1，并且将相邻单元格放入队列中。


~~~

class Solution {
public:
    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {
        if (grid[0][0] == 1) {
            return -1;
        }
        int n = grid.size();
        vector<vector<int>> dist(n, vector<int>(n, INT_MAX));
        queue<pair<int, int>> q;
        q.push({0, 0});
        dist[0][0] = 1;
        while (!q.empty()) {
            auto [x, y] = q.front();
            q.pop();
            if (x == n - 1 && y == n - 1) {
                return dist[x][y];
            }
            for (int dx = -1; dx <= 1; dx++) {
                for (int dy = -1; dy <= 1; dy++) {
                    if (x + dx < 0 || x + dx >= n || y + dy < 0 || y + dy >= n) { // 越界
                        continue;
                    }
                    if (grid[x + dx][y + dy] == 1 || dist[x + dx][y + dy] <= dist[x][y] + 1) { // 单元格值不为 0 或已被访问
                        continue;
                    }
                    dist[x + dx][y + dy] = dist[x][y] + 1;
                    q.push({x + dx, y + dy});
                }
            }
        }
        return -1;
    }
};

~~~


循环中的第2个if语句是为了不走回头路，如果发现遍历到的点的路径比当前路径加1要短，那么证明有一条比现有路径更短的到达该点的路径，我们就不用去更新它。